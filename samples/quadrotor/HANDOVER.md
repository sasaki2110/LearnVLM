# 引き継ぎドキュメント：Quadrotor チョン1実験

**最終更新**: 2026年1月25日（最新、roll入力時のyaw補正を実装完了）  
**対象**: `samples/quadrotor/` のチョン1・ホバリング検証

**重要**: PyBulletの速度取得は正しく動作していることが確認済み（`valcheck.py`による検証完了）  
**重要**: 機体座標系での速度検証の精度が大幅に改善（各ステップごとの座標変換を実装、約95%の誤差削減）  
**重要**: 位置変化記録のタイミング問題を修正完了（stepSimulation()後の位置を使用するよう統一）  
**重要**: ドリフト改善のためroll/pitch PIDを調整（Y方向ドリフト約38%改善、yaw回転約35%改善）  
**重要**: roll入力時のyaw補正を実装（Y方向ドリフトをさらに約36%改善、合計で約55%改善）

---

## 1. 目的・方針

**目的**: 目標位置を設定せず、**チョン1だけ**行ってホバリングし、**どれだけ位置が動いたか（Δx, Δy, Δz）を計測**する。  
その結果に基づいて、次のアクション（符号の決定、CHON の調整、チョンチョンや単純Pの検討）を決める。

**方針**: 閉ループの位置制御はいったんやめ、**開放系**で「1チョンの応答」を正確に測る。

---

## 2. ファイル構成

| ファイル | 役割 |
|----------|------|
| `pid_quadrotor.py` | ホバリングが安定。制御器のベース・参照用。 |
| `check_quadrotor.py` | 機体・URDF・ジョイント等の情報確認用。 |
| **`forward_quadrotor.py`** | **チョン実験用（1 チョン・長さスイープ、目標位置なし・開放系）**。メインの作業対象。 |
| **`forward_quadrotor_log.md`** | **計測ログ**。Run 別の条件・Δx,Δy,Δz・r,p,y・気づきを記録。 |
| **`valcheck.py`** | **速度検証スクリプト**。ホバリング中および動的状態での速度検証用。 |
| **`valcheck_log.md`** | **速度検証ログ**。速度取得タイミングと制御フローの検証結果を記録。 |
| **`control_flow_sequence.md`** | **制御フローのシーケンス図**。スクリプト→制御→PyBulletの流れを可視化。 |
| **`velocity_timing_analysis.md`** | **速度取得タイミングの分析**。n-1 vs nの速度取得タイミングを分析。 |

---

## 3. `forward_quadrotor.py` の仕様

### 3.1 流れ

1. **hover_start**: 3 s ホバ。終了時の `(x, y, z)` を `(x_start, y_start, z_start)` として記録。
2. **chon**: `controller.chon_roll_override = CHON_ROLL` を **CHON_DURATION [s]** のあいだ適用。この間だけ roll 目標が固定値になる（位置フィードバックなし）。
3. **chon 終了**: `chon_roll_override = None` のみ。**`reset()` は呼ばない**（呼ぶと roll/pitch の integral がゼロになり、過渡で振動・吹き上がりを招いたため）。
4. **hover_measure**: 2.5 s ホバ。終了時の `(x, y, z)` から `Δx = (x - x_start)*100`, `Δy`, `Δz` [cm] を計算し、「チョン1による位置変化」として表示。

### 3.2 定数

- `CHON_ROLL = 0.03` [rad]（≒1.72°）最大値。**正の roll → +X**（当機体で計測済み）。
- `CHON_DURATION` [s]：**0.2, 0.3, 0.4, 0.5 等のスイープ**用。長さを変えて「長さ→Δx」の感度を取る。
- **チョン後半で徐々にrollを減らす機能**（慣性低減のため）:
  - `ENABLE_GRADUAL_REDUCTION = True`: 徐々に減らす機能を有効にするか
  - `GRADUAL_REDUCTION_START = 1.0`: 減衰開始時刻 [s]（チョン開始から）
  - `GRADUAL_REDUCTION_DURATION = 4.0`: 減衰期間 [s]（1.0秒から5.0秒まで、線形減衰）

### 3.3 制御器

- `pid_quadrotor` と同系の推力・姿勢制御。
  - **推力配分**: `thrust_height_raw < 0` のとき全 0。`≥ 0` のとき roll/pitch をスケールし、**クリップによる吹き上がり**を防止。
  - **チョン中**: height の **integral を凍結**（`freeze_integral`）。
  - **roll / pitch PID**（2026年1月24日調整）:
    - `kp=5.0`（10.0から変更、振動抑制のため追従速度を下げる）
    - `ki=0.2`（0.5から変更、積分蓄積を抑制）
    - `kd=15.0`（10.0から変更、振動抑制を強化）
  - **yaw PID**: `kp=10.0, ki=0.3, kd=5.0`（yaw回転を抑制するため強化）
  - **roll入力時のyaw補正**（2026年1月25日実装）:
    - `ENABLE_YAW_COMPENSATION=True`
    - `YAW_COMP_GAIN=-0.3`（推奨値、Δx/Δyのバランスを考慮）
- **位置・速度PD（外側ループ）**: 実装済み（課題2: 慣性ドリフト低減）。
  - **速度D**: 
    - X方向: `roll += -kd_x * vel_x_body`（チョン中は無効化、チョンの効果を妨げないため）
    - Y方向: `pitch += -kd_y * vel_y_body`（**チョン中も有効**、ドリフト抑制のため）
  - **位置P**: 位置誤差を機体座標系に変換してから計算（`roll += kp_x * dx_body`, `pitch += -kp_y * dy_body`、チョン中は無効化）
  - **現在の設定**: `kp_x=0.05`, `kd_x=0.3`, `kp_y=0.05`, `kd_y=0.5`（KD_Y: 0.225→0.5に増加）, `target_x=0.0`, `target_y=0.0`
  - **座標変換**: ワールド座標系から機体座標系への変換を実装（yaw角度を使用）

### 3.4 機体・座標の前提

- **URDF**: prop1: +X（右）, prop2: +Y（前）, prop3: -X, prop4: -Y
- **推力配分**: prop1+roll, prop2+pitch, prop3-roll, prop4-pitch
- **ローター回転方向**: prop1とprop3が時計回り、prop2とprop4が反時計回り（対角線上で同じ回転方向）

---

## 4. 実行方法

```bash
cd /root/LearnVLM
python3 samples/quadrotor/forward_quadrotor.py
```

- **想定所要時間**: 約 6〜10 秒（ホバ 3s + チョン 0.2s + ホバ 2.5s と step 処理）。
- **出力**: フェーズごとの `(x,y,z)` と、最後に `Δx`, `Δy`, `Δz` [cm] および目標姿勢と実際の姿勢を表示。

---

## 5. 現在の実装状態

### 5.1 位置・速度PDの実装

- **実装済み**: `QuadrotorController` に位置・速度PDを追加
- **パラメータ設定**（`main()`内、2026年1月24日更新）:
  ```python
  ENABLE_POSITION_VELOCITY_PD = True
  KP_X = 0.05  # X方向の位置Pゲイン
  KD_X = 0.3   # X方向の速度Dゲイン
  KP_Y = 0.05  # Y方向の位置Pゲイン（符号修正済み）
  KD_Y = 0.5   # Y方向の速度Dゲイン（0.225→0.5、ドリフト抑制のため増加）
  TARGET_X = 0.0  # 目標X位置（原点）
  TARGET_Y = 0.0  # 目標Y位置（原点）
  ```

- **動作**:
  - **チョン中**: 
    - 位置P: 無効化（`chon_roll_override is None` のときのみ有効）
    - 速度D（X方向）: 無効化（チョンによるX方向加速を妨げないため）
    - 速度D（Y方向）: **有効**（ドリフト抑制のため）
  - **チョン終了後**: 位置Pと速度Dがすべて有効化され、目標位置（原点）に戻ろうとする力と速度抑制が働く
  - **解決策1実装**: 位置・速度PDの出力（`roll_offset`, `pitch_offset`）を姿勢PIDを経由せず、直接推力配分に反映
    - `roll_offset`と`pitch_offset`を角度から推力に変換（変換係数: `1 / (2.0 * arm_length)`）
    - 変換した推力オフセットを`thrust_roll`と`thrust_pitch`に直接加算
    - 姿勢PIDは姿勢の安定性のみを担当

### 5.2 最新の実行結果（yaw補正実装後、2026年1月25日）

- **条件**: 
  - `CHON_DURATION=5.0s`
  - `kp_x=0.05`, `kd_x=0.3`, `kp_y=0.05`, `kd_y=0.5`（KD_Y増加）
  - **roll/pitch PID調整**: `kp=5.0, ki=0.2, kd=15.0`（振動抑制）
  - **yaw PID強化**: `kp=10.0, ki=0.3, kd=5.0`
  - **位置Pと速度Dの両方を機体座標系に統一**
  - **チョン中もY方向の速度Dを有効化**（ドリフト抑制）
  - **チョン後半で徐々にrollを減らす**（減衰開始1.0秒、減衰期間4.0秒）
  - **解決策1実装**: 位置・速度PDの出力を直接推力配分に反映（姿勢PIDを経由しない）
  - **roll入力時のyaw補正**: `YAW_COMP_GAIN=-0.3`
- **結果**: 
  - Δx = +145.48 cm（yaw補正によりX方向移動が減少）
  - Δy = **-147.92 cm**（以前-230.90 cm → **約36%改善**、元の-373.97 cmから**約60%改善**）
  - Δz = -1.44 cm
  - 最終位置: (x,y,z)=(145.48, -147.92, 2.041) cm,cm,m
  - 最終速度（機体座標系）: vel_x_body=63.90 cm/s, vel_y_body=-25.48 cm/s
  - 最終姿勢: (r,p,y)=(-1.44°, 1.07°, **7.11°**）
- **改善の要因**:
  - **yaw補正**: thrust_rollに比例してyawトルクを補正し、反トルクの偏りを軽減
  - **副作用**: X方向移動量も減少（253.89 cm → 145.48 cm）

### 5.2.1 yaw補正なしの結果（2026年1月24日、参考）

- **結果（yaw補正なし）**: 
  - Δx = +253.89 cm
  - Δy = -230.90 cm
  - yaw = 7.15°

### 5.2.1 ドリフト改善前の結果（参考）

- **結果（改善前）**: 
  - Δx = +86.15 cm
  - Δy = -373.97 cm
  - yaw = 10.94°
- **問題点**:
  - roll PIDの振動（-9°〜+9°の間でオーバーシュート/アンダーシュート）
  - 振動による推力アンバランス → 累積的なyaw回転
  - yaw回転した状態でroll入力 → Y方向にも力が発生

### 5.3 重要な発見

#### 座標変換は正しく実装されている（検証済み）

- **検証結果**: `vel_body(state)`と`vel_body(再計算)`がほぼ一致（0.01 cm/sの差は計算誤差の範囲）
- **結論**: 機体軸と世界軸の変換は数学的に正しく、実装も正しい

#### PyBulletの速度は正しく動作している（検証済み、2026年1月23日）

- **検証方法**: `valcheck.py`によるn-1とnの速度の詳細検証
- **結果**: ホバリング中は完全一致（誤差 < 0.1 cm/s、位置変化の予測精度も良好）
- **結論**: PyBulletの速度取得そのものは正しく動作している
- **問題の本質**: 制御に使用する速度が1ステップ遅れている（n-1の速度でnの制御をしている）ため、加速度が大きい時に不一致が発生

#### 位置変化記録のタイミング問題（2026年1月24日修正完了）

- **問題**: `controller.update()`から取得した位置（`state['x'], state['y']`）は**stepSimulation()前の値**であり、位置変化の記録に使用すると不正確な結果になる
- **修正内容**: `stepSimulation()`後に`p.getBasePositionAndOrientation()`で位置を取得し、その値（`x_after, y_after`）を使用して位置変化を記録
- **効果**: 位置変化の一致度が完全に0（`Δdx=0.0000 Δdy=0.0000 cm`）、方法2の速度の差が143 cm/s → 約2 cm/sに改善

#### 解決策1の効果

- **改善点**: 解決策1の実装により、位置・速度PDの出力を直接推力配分に反映することで、姿勢PIDとの相互作用を回避
- **結論**: 姿勢PIDと位置・速度PDの分離により、制御の安定性が向上

---

## 6. 現在の課題と対応事項（最優先）

### 6.1 PyBulletの速度検証結果（2026年1月23日完了）

**結論**: **PyBulletの速度取得は正しく動作している**

#### 検証方法

`valcheck.py`を使用して、n-1とnの速度をロギングし、以下の検証を実施：

1. **位置変化から計算した速度**（n-1→nの平均速度）
2. **n-1とnの速度の平均**（台形公式）
3. **加速度を考慮した位置変化の予測**（等加速度運動を仮定）
4. **速度の積分**（台形公式）による位置変化の予測
5. **機体座標系での速度検証**
6. **Simpson法による位置変化の予測**（高精度、等間隔）

#### 検証結果

**ホバリング中（t=4.00s, 5.00s）**:
- ✅ **速度の一致度**: 良好（誤差 < 0.1 cm/s）
- ✅ **位置変化の予測精度**: 良好（誤差 < 0.01 cm）
- ✅ **Simpson法の予測精度**: 良好（誤差 < 0.01 cm）
- **結論**: PyBulletの速度取得は正しく動作している

**動的状態（t=6.00s以降）**:
- ❌ **速度の一致度**: 悪い（誤差 >= 1.0 cm/s）
- ❌ **位置変化の予測精度**: 悪い（誤差 >= 0.1 cm）
- ❌ **Simpson法の予測精度**: 悪い（誤差 >= 0.1 cm）

ただし、これは「PyBulletの速度が間違っている」という意味ではない。

#### 問題の本質

**速度取得タイミングの問題**:
- `controller.update()`内で取得した速度は**n-1の状態**（前回の`stepSimulation()`後の状態）
- 位置変化から計算した速度は**nとn-1の間の平均速度**
- これらは**異なるタイミング**の速度なので、加速度がある場合は一致しないのは当然

**制御ループのタイミング**:
```
ループ n:
  1. controller.update() → getBaseVelocity() → vel_n-1 を取得（前回のstepSimulation()後の状態）
  2. PID制御で推力計算（vel_n-1を使用）
  3. apply_thrusts() → 力を適用
  4. stepSimulation() → 位置・速度を更新 → pos_n, vel_n が計算される
```

**重要な前提確認**:
- ✅ **座標変換は正しく実装されている**: 機体軸と世界軸の変換は数学的に正しく、実装も正しい（検証済み）
- ✅ **PyBulletの速度取得は正しく動作している**: ホバリング中は完全一致（検証済み）
- ⚠️ **問題は制御ループのタイミング**: 制御に使用する速度が1ステップ遅れている（n-1の速度でnの制御をしている）

**検証ツール**:
- `valcheck.py`: 速度検証スクリプト（n-1とnの速度をロギング、Simpson法による等間隔検証実装済み）
- `control_flow_sequence.md`: 制御フローのシーケンス図
- `velocity_timing_analysis.md`: 速度取得タイミングの詳細分析
- `valcheck_error_analysis.md`: 誤差の原因分析（ログ間隔と姿勢変化の影響）
- `logs/valcheck.log`: 速度検証結果の実行ログ

### 6.2 機体座標系での速度検証の改善（2026年1月24日完了）

**問題の発見**:
- ログ間隔を1秒から10ステップ（約0.04秒）に短くしても、動的状態で大きな誤差が発生
- 誤差の原因は、n-1とnのずれだけではなく、**姿勢変化（yaw角度の変化）による座標変換の影響**が大きいことが判明

**問題の本質**:
- 位置変化（dx, dy）は、n-1からnまでの間（0.04秒）の変化（ワールド座標系）
- これを機体座標系に変換する際、**nのyaw角度のみ**を使用していた
- しかし、**n-1からnまでの間にyaw角度が変化している**（例：t=6.00sで0.04秒間に0.54°変化）
- そのため、nのyaw角度で変換した位置変化は、実際の機体座標系での位置変化と一致しない

**解決策の実装**:
- **各ステップごとの座標変換**を実装（`valcheck.py`）
  - ログ間隔（10ステップ）の間、各ステップの位置変化（dx, dy）とyaw角度を記録
  - ログ出力時に、各ステップの位置変化をそのステップのyaw角度で機体座標系に変換
  - 変換後の位置変化を合計し、より正確な機体座標系での速度を計算

**改善結果**:
- **t=6.00s（動的状態）**:
  - 方法1（nのyaw角度のみ）: 誤差 Δvel_x_body=21.01 cm/s, Δvel_y_body=26.38 cm/s
  - 方法2（各ステップごとの変換）: 誤差 Δvel_x_body=1.03 cm/s, Δvel_y_body=1.12 cm/s
  - **約95%の誤差削減**（21.01→1.03 cm/s）
- **t=6.04s（動的状態）**:
  - 方法1: 誤差 Δvel_x_body=23.67 cm/s, Δvel_y_body=28.76 cm/s
  - 方法2: 誤差 Δvel_x_body=1.22 cm/s, Δvel_y_body=1.05 cm/s
  - **約95%の誤差削減**（23.67→1.22 cm/s）

**結論**:
- ✅ **姿勢変化を考慮した座標変換が有効**: 各ステップごとの座標変換により、機体座標系での速度検証の精度が大幅に改善
- ✅ **計算コストは実用的**: 10ステップごとの座標変換（cos/sin 2回、乗算4回、加算2回）は軽量で実用的
- ⚠️ **残る誤差（1-1.2 cm/s）**: 加速度が大きい場合の台形公式の限界によるものと考えられる

**実装詳細**:
- `valcheck.py`: 各ステップごとの座標変換を実装（方法1と方法2の比較出力）
- `valcheck_error_analysis.md`: 誤差の原因分析と解決策の詳細

**`forward_quadrotor.py`への実装（2026年1月24日完了）**:
- `valcheck.py`で有効性が確認された各ステップごとの座標変換を`forward_quadrotor.py`に実装
- チョン中と10.0s以降のログ出力時に、各ステップごとの座標変換を使用した速度計算を追加
- **問題の発見と修正**:
  - **問題1**: ログ出力時に位置変化の合計が一致しない（Y方向で大きな不一致）
  - **原因**: `controller.update()`から取得した位置（`state['x'], state['y']`）は**stepSimulation()前の値**であり、位置変化の記録に使用すると不正確
  - **修正**: `stepSimulation()`後に`p.getBasePositionAndOrientation()`で位置を取得し、その値（`x_after, y_after`）を使用
  - **結果**: 位置変化の一致度が完全に0（`Δdx=0.0000 Δdy=0.0000 cm`）
- **修正箇所**:
  - 各ステップの位置変化の記録：`x_after, y_after`を使用
  - チョン開始時の基準点設定：`x_after, y_after`を使用
  - ログ出力時の位置変化計算：`x_after, y_after`を使用
  - hover_measureフェーズの位置変化計算：`x_after, y_after`を使用
  - 最終結果の出力：`x_after, y_after`を使用

### 6.3 ドリフト改善の調査と対策（2026年1月24日完了）

**問題の原因特定**:
1. **roll PIDの振動**: roll目標（1.72°）に追従しようとする際に、-9°〜+9°の間でオーバーシュート/アンダーシュートを繰り返していた
2. **振動による推力アンバランス**: roll振動が対角ローターの推力差を引き起こし、累積的なyaw回転を発生させた
3. **yaw回転とroll入力の相互作用**: yaw回転した状態でrollを入力すると、Y方向にも力が発生

**実施した改善**:
1. **roll/pitch PIDのゲイン調整**:
   - `kp: 10.0 → 5.0`（追従速度を下げて振動抑制）
   - `ki: 0.5 → 0.2`（積分蓄積を抑制）
   - `kd: 10.0 → 15.0`（振動抑制を強化）
2. **速度D制御の有効化**:
   - Y方向の速度Dをチョン中も有効化（ドリフト抑制）
   - X方向の速度Dはチョン中は無効（チョンの効果を妨げない）
3. **KD_Yの増加**: `0.225 → 0.5`（Y方向ドリフト抑制）
4. **yaw PIDの強化**: `kp: 5.0→10.0, ki: 0.1→0.3, kd: 2.0→5.0`

**改善結果**:
| 項目 | 改善前 | 改善後 | 改善率 |
|------|--------|--------|--------|
| Δy | -373.97 cm | -230.90 cm | **約38%改善** |
| yaw | 10.94° | 7.15° | **約35%改善** |
| roll振動 | -9°〜+9° | -5°〜+5° | **大幅減少** |

**残る課題**:
- ドリフトは完全に解消されていない（Δy = -230.90 cm）
- さらなる改善には制御構造の見直しが必要（例：roll入力時のyaw補正）

### 6.4 roll入力時のyaw補正の実装（2026年1月25日完了）

**実装内容**:
- `QuadrotorController`に`enable_yaw_compensation`と`yaw_comp_gain`パラメータを追加
- thrust_roll（姿勢PID + 位置・速度PDの出力）に比例してyawトルクを補正
- 補正式: `yaw_compensation = yaw_comp_gain * thrust_roll * 2.0 * moment_coeff`
  - `moment_coeff = 0.0245`（ローターのモーメント係数）

**パラメータ調整結果**:
| ゲイン | Δx | Δy | yaw | 備考 |
|--------|-----|-----|-----|------|
| 0（無効） | +253.89 cm | -230.90 cm | 7.15° | ベースライン |
| -0.2 | +181.76 cm | -177.47 cm | 7.12° | Δy: 23%改善 |
| **-0.3** | **+145.48 cm** | **-147.92 cm** | **7.11°** | **推奨値**、Δy: 36%改善 |
| -0.5 | +84.83 cm | -102.88 cm | 7.10° | Δy: 55%改善、Δx大幅減少 |
| -1.0 | -90.12 cm | +30.82 cm | 7.09° | 過補正（Δx逆転）|

**考察**:
- yaw補正はY方向ドリフトの改善に効果的
- ただし、X方向移動量（チョンの効果）も同時に減少する
- yaw角度自体はほとんど変化しない（7.1°前後）
- **ゲイン-0.3**がΔxとΔyのバランスを考慮した推奨値

### 6.5 次のステップ

- **優先度1**: 制御パラメータのさらなる最適化
  - yaw補正ゲインの微調整（用途に応じて-0.2〜-0.5の範囲で調整）
  - 位置・速度PDゲインの再調整
- **優先度2**: 制御ループのタイミング改善の検討
  - 現在の実装では、n-1の速度でnの制御をしているため、1ステップの遅れが発生
  - この遅れは、加速度が大きい時に不一致として現れる
  - ホバリング中（加速度が小さい）では問題にならない
- **優先度3**: 速度フィードバック制御の検証
  - 現在の実装では、速度D制御にn-1の速度を使用している
  - この1ステップの遅れが制御性能に与える影響を評価

---

## 7. 座標変換の検証結果（検証済み）

### 7.1 座標変換式の検証

**検証結果**: ✅ **座標変換は正しく実装されている**

1. **数学的検証**: 完了
   - ワールド座標系から機体座標系への変換式を確認
   - 機体座標系からワールド座標系への逆変換式を確認
   - **結果**: 数学的には正しい（回転行列の逆行列は転置）

2. **実装の確認**: 完了
   - `forward_quadrotor.py`の座標変換式を確認
   - **結果**: 実装は数学的に正しい

3. **実際のシミュレーションでの検証**: 完了
   - `vel_body(state)`と`vel_body(再計算)`がほぼ一致（0.01 cm/sの差は計算誤差の範囲）
   - 逆変換も正しく機能している
   - **結論**: 座標変換は正しく実装されている

### 7.2 座標変換式の詳細

**ワールド座標系から機体座標系への変換**:
```
[vel_x_body]   [cos(yaw)  sin(yaw)] [vel_x_world]
[vel_y_body] = [-sin(yaw) cos(yaw)] [vel_y_world]
```

**機体座標系からワールド座標系への逆変換**:
```
[vel_x_world]   [cos(yaw) -sin(yaw)] [vel_x_body]
[vel_y_world] = [sin(yaw)  cos(yaw)] [vel_y_body]
```

**実装場所**:
- ワールド→機体: `forward_quadrotor.py`の118-119行目
- 機体→ワールド: `forward_quadrotor.py`の421-422行目（デバッグログ内）

### 7.3 姿勢変化を考慮した座標変換（2026年1月24日実装）

**問題**:
- 位置変化（dx, dy）を機体座標系に変換する際、nのyaw角度のみを使用していた
- n-1からnまでの間にyaw角度が変化している場合、誤差が発生する

**解決策**:
- **各ステップごとの座標変換**: ログ間隔の間、各ステップの位置変化をそのステップのyaw角度で機体座標系に変換
- 変換後の位置変化を合計し、より正確な機体座標系での速度を計算

**実装場所**:
- `valcheck.py`: 各ステップごとの座標変換を実装（方法1と方法2の比較出力）
  - ログ間隔（10ステップ）の間、各ステップの位置変化（dx, dy）とyaw角度を記録
  - ログ出力時に、各ステップの位置変化をそのステップのyaw角度で機体座標系に変換
- `forward_quadrotor.py`: 各ステップごとの座標変換を実装（2026年1月24日実装中）
  - チョン中と10.0s以降のログ出力時に、各ステップごとの座標変換を使用した速度計算を追加
  - ログ間隔（240ステップ = 1秒）の間、各ステップの位置変化（dx, dy）とyaw角度を記録
  - ログ出力時に、各ステップの位置変化をそのステップのyaw角度で機体座標系に変換
  - **基準点の不一致問題を修正中**: ログ間隔の開始時の基準点を保存する変数を追加し、基準点を統一

**効果**:
- `valcheck.py`での動的状態での機体座標系での速度検証の誤差が約95%削減（21-24 cm/s → 1-1.2 cm/s）
- 姿勢変化の影響を考慮した正確な機体座標系での速度計算が可能に
- `forward_quadrotor.py`への実装が完了（2026年1月24日）
  - 位置変化記録のタイミング問題を修正（stepSimulation()後の位置を使用）
  - 位置変化の一致度が完全に0（`Δdx=0.0000 Δdy=0.0000 cm`）


---

## 8. これまでの主要な経過

- **吹き上がり対策**: 推力配分の修正、チョン中のheight integralの凍結、`reset()`を呼ばない → 完了
- **姿勢制御の改善**: roll/pitchのkdを5.0→10.0に強化 → 完了
- **位置・速度PDの実装**: 外側ループとして実装 → 完了
- **Y方向の位置Pの符号修正**: `pitch_offset += -self.kp_y * (self.target_y - y)` → 完了（Run 23）
- **純粋なホバリング**: 試行したが、水平速度を抑制できないため、位置・速度PDが必要 → 確認済み（Run 24）
- **姿勢PIDのゲイン調整**: kp=15, 20を試行したが、フィードバックループの相互作用で悪化 → 失敗（Run 27-28）
- **外側ループのゲイン調整**: 下げる試行は改悪（ドリフトが増加） → 失敗（Run 29）
- **チョン後半で徐々にrollを減らす**: 効果あり → 完了（Run 30-31）
  - Run 30: 減衰開始2.0秒、減衰期間3.0秒 → Δxが約43%改善
  - Run 31: 減衰開始1.0秒、減衰期間4.0秒 → さらなる改善（Δxが約54%改善）
- **X方向とY方向のドリフトの違いを発見**: Y方向は抑制されているが、X方向が大きい → 確認済み（Run 31）
- **詳細ログの追加**: 10.0s以降のvel_xの推移を確認するため → 完了
- **座標系の統一**: 位置Pと速度Dの両方を機体座標系に統一 → 完了（Run 32）
- **座標変換の検証**: 機体軸と世界軸の変換が正しく実装されていることを確認 → 完了（2025年1月）
- **解決策1の実装**: 位置・速度PDの出力を直接推力配分に反映（姿勢PIDを経由しない） → 完了
  - **効果**: 姿勢PIDが位置・速度PDの出力を打ち消す問題を回避
- **速度検証スクリプトの作成**: `valcheck.py`を作成し、ホバリング中および動的状態での速度検証を実装 → 完了（2026年1月23日）
- **n-1とnの速度の検証**: `valcheck.py`でn-1とnの速度をロギングし、Simpson法による等間隔検証を実装 → 完了（2026年1月23日）
- **PyBulletの速度が正しく動作していることを確認**: ホバリング中は完全一致（誤差 < 0.1 cm/s）を確認 → 完了（2026年1月23日）
- **問題の本質を明確化**: 制御に使用する速度が1ステップ遅れている（n-1の速度でnの制御をしている）ことを確認 → 完了（2026年1月23日）
- **制御フローの可視化**: シーケンス図を作成し、スクリプト→制御→PyBulletの流れを明確化 → 完了（2026年1月23日）
- **ログ間隔の短縮**: 1秒から10ステップ（約0.04秒）に短縮し、姿勢変化の影響を最小限に抑える → 完了（2026年1月24日）
- **誤差の原因分析**: 姿勢変化（yaw角度の変化）による座標変換の影響が大きいことを発見 → 完了（2026年1月24日）
- **各ステップごとの座標変換の実装（valcheck.py）**: 機体座標系での速度検証の精度を大幅に改善（約95%の誤差削減） → 完了（2026年1月24日）
- **各ステップごとの座標変換の実装（forward_quadrotor.py）**: `forward_quadrotor.py`に実装 → 完了（2026年1月24日）
  - **問題の発見**: ログ出力時に位置変化の合計が一致しない問題を発見（Y方向で大きな不一致）
  - **根本原因の特定**: `controller.update()`から取得した位置は**stepSimulation()前の値**であり、位置変化の記録に不適切
  - **修正**: `stepSimulation()`後に`p.getBasePositionAndOrientation()`で位置を取得し、その値（`x_after, y_after`）を使用
  - **結果**: 位置変化の一致度が完全に0（`Δdx=0.0000 Δdy=0.0000 cm`）、方法2の速度の差が約2 cm/sに改善
- **チョン中のY方向の移動を発見**: 修正後の結果で、チョン中にY方向に約374 cm移動していることが判明（2026年1月24日）
  - 以前の結果（Δy≈+19 cm）は不正確な位置データに基づいていた
  - 実際にはY方向（-Y方向）に大きく移動している
- **ドリフトの原因調査**: roll PIDの振動がyaw回転を引き起こしていることを特定（2026年1月24日）
  - roll目標への追従時に-9°〜+9°の振動が発生
  - 振動による推力アンバランスが累積的なyaw回転を発生させていた
- **roll/pitch PIDの調整**: 振動抑制のためゲインを調整（2026年1月24日）
  - `kp: 10.0 → 5.0`、`ki: 0.5 → 0.2`、`kd: 10.0 → 15.0`
  - **効果**: roll振動が-5°〜+5°に減少、yaw回転が10.94° → 7.15°に改善
- **チョン中のY方向速度Dを有効化**: ドリフト抑制のため（2026年1月24日）
  - KD_Yを0.225 → 0.5に増加
  - **効果**: Δyが-373.97 cm → -230.90 cmに改善（約38%改善）
- **roll入力時のyaw補正を実装**（2026年1月25日）
  - thrust_rollに比例してyawトルクを補正
  - `YAW_COMP_GAIN=-0.3`（推奨値）
  - **効果**: Δyが-230.90 cm → -147.92 cmに改善（約36%改善）
  - **副作用**: Δxも253.89 cm → 145.48 cmに減少（チョンの効果が弱まる）

詳細な経過は `forward_quadrotor_log.md` と `forward_quadrotor_log_archive.md` を参照。

---

## 9. 参考ドキュメント

### 検証・ログファイル

- **`forward_quadrotor_log.md`**: 重要なマイルストーンと最新の実行結果
- **`forward_quadrotor_log_archive.md`**: 詳細な試行錯誤ログ
- **`logs/valcheck.log`**: 速度検証スクリプトの実行ログ（n-1とnの速度検証、Simpson法による等間隔検証を含む）
- **`logs/forward_quadrotor_velocity.log`**: チョン動作中の速度検証ログ

### 分析ドキュメント

- **`control_flow_sequence.md`**: 制御フローのシーケンス図（スクリプト→制御→PyBulletの流れを可視化）（2026年1月23日作成）
- **`velocity_timing_analysis.md`**: 速度取得タイミングの詳細分析（n-1 vs n）（2026年1月23日作成）
- **`valcheck_error_analysis.md`**: 誤差の原因分析（ログ間隔と姿勢変化の影響、各ステップごとの座標変換による改善）（2026年1月24日作成）

### 検証スクリプト

- **`valcheck.py`**: 速度検証スクリプト（n-1とnの速度をロギング、Simpson法による等間隔検証実装済み、各ステップごとの座標変換機能追加）（2026年1月24日更新）
- **`forward_quadrotor.py`**: チョン実験用（速度検証ログ機能追加済み）

### 古い参考ドキュメント（参考用）

- **`CONTROL_FLOW.md`**: 制御の流れ（外側ループと内側ループの関係）
- **`DRIFT_ANALYSIS.md`**: X方向とY方向のドリフトの違いの分析
- **`GRADUAL_REDUCTION_ANALYSIS.md`**: チョン後半で徐々にrollを減らすアプローチの検討
- **`CHON_BRAKING_ANALYSIS.md`**: チョン中に位置P・速度Dを適用する検討
- **`STATUS.md`**: 現在の状況（行き詰まりの整理）

## 10. その他

- シミュレーションの `dt` は `1/240`、`time.sleep(dt)` あり（実時間に近い進行）。
- `Quadrotor` モデルは `/root/LearnVLM/Quadrotor/` を参照（`forward_quadrotor.py` 内で `project_root` から解決）。
- PyBullet接続は `p.GUI`（描画が必要な場合）または `p.DIRECT`（WSL等でGUIが使えない場合）。

---

以上。
